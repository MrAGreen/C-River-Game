/** @file rivers.h */

#pragma once
#include <map>
#include <string>
#include <vector>
#include <deque>
#include <random>
#include <fstream>
#include <iostream>
#include <ostream>
#include <iterator>
#include <thread>
#include <mutex>
#include <chrono>
#include <filesystem>

/**
 * @brief Class representing river information and functionalities for random river name generation.
 *
 * The `Rivers` class provides functionalities for managing river data and generating random river names based on user-selected modes.
 * It utilizes various data structures to store river names, continents, and weights for random selection.
 */
class Rivers {

private:

	/**
	 * @brief Map organizing rivers based on continents.
	 *
	 * This `std::map` uses continent names as keys and stores vectors of river names (`std::vector<std::string>`) as values.
	 * It enables efficient random selection of rivers within a specific continent.
	 */
	std::map<std::string, std::vector<std::string>> ContWeight;

	/**
	 * @brief Deque for tracking recently generated rivers (FIFO).
	 *
	 * This `std::deque<std::string>` stores recently generated river names, allowing retrieval of the most recently generated ones and maintaining a limited history (implemented with first-in, first-out - FIFO - behavior).
	 */
	std::deque<std::string> usedRivers;

	/**
	 * @brief String storing the name of the continent used in the previous random generation (for mode 3).
	 *
	 * This `std::string` variable tracks the continent used in the most recent random river generation, specifically relevant for mode 3 ("favor previously used continent").
	 */
	std::string usedContinent;

	/**
	 * @brief Mersenne Twister object for generating random numbers.
	 *
	 * This `std::mt19937_64` object is a Mersenne Twister pseudo-random number generator (PRNG) used to provide a strong source of randomness for selecting continents and rivers.
	 */
	std::mt19937_64 randomGen;

	/**
	 * @brief Integer used as a temporary variable to hold randomly generated integers during river selection.
	 *
	 * This `int` variable `rnd` is a temporary storage for random integers generated by `randomGen` and used within river selection algorithms.
	 */
	int rnd;

	/**
	 * @brief Boolean flag indicating whether it's the first time a river has been generated.
	 *
	 * This `bool` variable `firstGeneration` is a flag used in mode 3 to handle the initial random selection differently (ensuring initial random selection across continents).
	 */
	bool firstGeneration;

public:

	/**
	 * @brief Integer storing the user-selected mode (1: equal weights for continents, 2: equal weights for rivers, 3: favor previously used continent).
	 *
	 * This `int` variable `myMode` holds the current operating mode chosen by the user, governing how continents and rivers are weighted for random selection.
	 */
	int myMode;

	/**
	 * @brief Map storing associations between river names and their corresponding continents.
	 *
	 * This `std::map` efficiently retrieves the continent for a given river name using the river name as the key and the continent name as the value.
	 */
	std::map<std::string, std::string> rivers;

	/**
	* @brief Constructor for the Rivers class, initializing data and reading river data from multiple files.
	*
	* This constructor performs the following steps to set up the `Rivers` object:
	* 1. **Initialization:**
	*    - Sets `firstGeneration` flag to `true`, indicating it's the first time a random river will be generated (used in mode 3).
	*    - Sets `myMode` to 2, representing the default mode (equal weights for individual rivers).
	*    - Creates a `mutex` object for thread safety during parallel file reading.
	*    - Initializes a `randomGen` object using `std::random_device` to seed a Mersenne Twister random number generator.
	* 2. **Parallel File Reading:**
	*    - Creates a vector named `files` to store thread objects.
	*    - Iterates through the provided `filenames` vector:
	*    - For each file name `f`, creates a new thread object `t1` using the `fileRead` member function as the target.
	*    - Passes `this` pointer (current object), `f` (file name), and a reference to the `mutex` object as arguments to `fileRead`.
	*    - Pushes the created thread object `t1` into the `files` vector.
	*    - Waits for all threads to finish by iterating through the `files` vector:
	*    - For each thread object in `files`, calls the `join` method to wait for that thread to complete.
	*
	* This constructor essentially uses threads to concurrently read and store river data from multiple files, improving efficiency. The `mutex` ensures thread safety while accessing shared data during this process.
	*
	* @param filenames A vector of `std::string` containing file names. Each file represents a continent and contains river names, with the continent name as the first part of each line in the file.
	*
	* Time Complexity: O(n) - Linear time.
	*/
	Rivers(const std::vector<std::string>& filenames);
	/**
	 * @brief Reads river data from a single file and stores it in the Rivers object.
	 *
	 * This function is designed to be called by a thread and takes the following steps:
	 * 1. **File Opening and Error Handling:**
	 *    - Creates an `std::fstream` object named `file` to open the provided `filenames` string.
	 *    - Checks if the file was opened successfully using `file.is_open()`. If not, potential error handling (e.g., throwing an exception or logging an error) can be implemented here (not shown).
	 * 2. **Continent Extraction:**
	 *    - Extracts the continent name from the `filenames` string by taking a substring from the beginning to the length minus 4 (assuming the file name format includes the continent name followed by ".txt").
	 *    - Converts the first character of the continent name to uppercase using `toupper`.
	 * 3. **River Data Processing (Within Mutex Lock):**
	 *    - Creates a local string variable `r` to store each line read from the file.
	 *    - Creates a local vector `vec` to temporarily store rivers for this continent.
	 *    - Iterates through the file line by line using `getline(file, r)`.
	 *    - Acquires the lock on the `mutex` object to ensure thread safety during shared data access.
	 *    - Stores the river name (`r`) and its corresponding continent (`cont`) in the `rivers` map.
	 *    - Pushes the river name into the local `vec` vector.
	 *    - Releases the lock on the `mutex` after modifications.
	 * 4. **Continent-River Mapping (Outside Mutex):**
	 *    - After processing all lines in the file, adds a new entry to the `ContWeight` map.
	 *    - The key for the new entry is the continent name (`cont`).
	 *    - The value for the new entry is the local vector `vec` containing all river names for that continent.
	 *
	 * @param filenames The name of the file containing river data (assumed format: continent_name.txt)
	 * @param mutex A reference to the mutex object for thread safety
	 *
	 * Time Complexity: O(1) + O(n * log n)
	 */
	void fileRead(std::string filenames, std::mutex& mutex);

	/**
	* @brief Creates a discrete distribution for mode 1, where continents have equal weights.
	*
	* This function generates a discrete distribution that assigns equal probabilities to each continent. It follows these steps:
	* 1. **Weight Initialization:**
	*    - Creates a vector named `weights` to store weights for the distribution.
	*    - Iterates through the `ContWeight` map (which maps continents to vector of rivers):
	*      - Pushes a weight of 1 (representing equal probability) for each continent into the `weights` vector.
	* 2. **Distribution Creation:**
	*    - Constructs a `std::discrete_distribution` object named `dis`, using iterators to the beginning and end of the `weights` vector as arguments. This creates a distribution that represents the equal probabilities for each continent.
	* 3. **Distribution Return:**
	*    - Returns the created `dis` object, which can be used for random sampling of continents with equal weights.
	*
	* @return std::discrete_distribution<double> A discrete distribution with equal weights for continents
	* Time Complexity: O(n) - Linear time.
	*/
	std::discrete_distribution<> modeOne();
	/**
	* @brief Creates a discrete distribution for mode 2, where individual rivers have equal weights.
	*
	* This function generates a discrete distribution that assigns equal weights to each individual river. It follows these steps:
	* 1. **Weight Initialization:**
	*    - Creates a vector named `weights` to store weights for the distribution.
	*    - Iterates through the `ContWeight` map (which maps continents to vector of rivers):
	*    - Pushes the size of the continent's river vector (`i.second.size()`) into the `weights` vector. This assigns a weight equal to the number of rivers in each continent.
	* 2. **Distribution Creation:**
	*    - Constructs a `std::discrete_distribution` object named `dis`, using iterators to the beginning and end of the `weights` vector as arguments. This creates a distribution where each river (represented by its position in the combined river list) has an equal probability of being chosen.
	* 3. **Distribution Return:**
	*    - Returns the created `dis` object, which can be used for random sampling of rivers with equal weights.
	*
	* @return std::discrete_distribution<double> A discrete distribution with equal weights for individual rivers
	*
	*Time Complexity: O(n) - Linear time.
	*/
	std::discrete_distribution<> modeTwo();
	/**
	 * @brief Creates a discrete distribution for mode 3, favoring the previously used continent.
	 *
	 * This function generates a discrete distribution that assigns a higher weight to the continent used in the previous round and distributes the remaining weight (50%) equally among other continents. It follows these steps:
	 * 1. **Weight Initialization:**
	 *    - Creates a vector named `weights` to store weights for the distribution.
	 *    - Iterates through the `ContWeight` map (which maps continents to vector of rivers):
	 *    - If the continent's name (`i.first`) matches the `usedContinent` member variable (continent used in the previous round):
	 *    - Pushes a weight of 50 into the `weights` vector, giving it higher probability.
	 *    - Otherwise, calculates a weight based on the total number of continents (`ContWeight.size()`):
	 *    - The weight is calculated as `50 / (ContWeight.size() - 1)`, effectively distributing the remaining 50% weight equally among all other continents.
	 * 2. **Distribution Creation:**
	 *    - Constructs a `std::discrete_distribution` object named `dis`, using iterators to the beginning and end of the `weights` vector as arguments. This creates a distribution where the previously used continent has a higher chance of being selected.
	 * 3. **Distribution Return:**
	 *    - Returns the created `dis` object, which can be used for random sampling of continents with biased weights favoring the previously used one.
	 *
	 * @return std::discrete_distribution<double> A discrete distribution favoring the previously used continent
	 *
	 * Time Complexity: O(n) - Linear time.
	 */

	std::discrete_distribution<> modeThree();

	/**
	 * @brief Generates a random river name based on the selected mode.
	 *
	 * This function selects a random river name following these steps:
	 * 1. **Distribution Selection:**
	 *    - Declares a `std::discrete_distribution<>` object named `dis`.
	 *    - Uses a `switch` statement based on the `myMode` member variable to determine the appropriate weight distribution:
		  - If `myMode` is 1 (equal weights for continents):
			- Calls the `modeOne` function to create a distribution with equal weights for continents and assigns it to `dis`.
		  - If `myMode` is 2 (equal weights for rivers):
			- Calls the `modeTwo` function to create a distribution with equal weights for individual rivers and assigns it to `dis`.
		  - If `myMode` is 3 (favor previously used continent):
			- Checks the `firstGeneration` flag:
			  - If `firstGeneration` is true (first time calling this function), it calls the `modeTwo` function (equal weights for rivers) to ensure initial random selection across continents.
			  - Otherwise, it calls the `modeThree` function to create a distribution favoring the previously used continent and assigns it to `dis`.
	 * 2. **Random Continent Selection:**
	 *    - Generates a random number using the chosen `dis` object and the Mersenne Twister random number generator (`randomGen`). This selects a continent based on the weight distribution.
	 *    - Creates an iterator `it` pointing to the beginning of the `ContWeight` map.
	 *    - Uses `std::advance` to move the iterator `it` forward by the number of positions indicated by the random number (`rnd`). This effectively positions the iterator to the continent chosen based on the weight distribution.
	 * 3. **Random River Selection Within Continent:**
	 *    - Creates a `std::uniform_int_distribution<>` object named `dist` to generate a random integer within the range of 0 to the size of the chosen continent's river vector minus 1 (to account for zero-based indexing).
	 *    - Generates a random number using the `dist` object and the Mersenne Twister random number generator. This selects a specific river name from the chosen continent's river vector.
	 * 4. **Updating Tracking Variables:**
	 *    - Assigns the chosen continent's name to the `usedContinent` member variable for tracking purposes in mode 3.
	 *    - Sets the `firstGeneration` flag to false to indicate that the initial random selection (if applicable in mode 3) has been performed.
	 * 5. **Returning River Name:**
	 *    - Returns the randomly selected river name from the chosen continent's river vector using the iterator `it` and the random number (`num`) for indexing.
	 *
	 * @return std::string A randomly selected river name
	 *
	 * Time Complexity: O(n) - Linear time.
	 */

	std::string newRandomRiver();

	/**
	 * @brief Obtains a randomly generated river name, avoiding recent duplicates.
	 *
	 * This function generates a unique random river name within a limited history, following these steps:
	 * 1. **Initial Random River Generation:**
	 *    - Calls the `newRandomRiver` function to generate a random river name based on the selected mode and weighting strategy.
	 * 2. **Duplicate Check Loop:**
	 *    - Enters a `while` loop to ensure the generated river name is unique within a limited history:
		  - Uses `std::find` to search for the generated river name in the `usedRivers` deque (a container that stores recently used rivers).
		  - If the river is found (`it != usedRivers.end()`), it's considered a duplicate:
			- Regenerates a new random river name using `newRandomRiver`.
			- Continues to the beginning of the loop for further checks.
		  - If the river is not found (`it == usedRivers.end()`), a unique river has been generated, so the loop breaks.
	 * 3. **History Maintenance:**
	 *    - If the `usedRivers` deque is full (size = 6):
		  - Removes the oldest river name from the front of the deque using `pop_front` to maintain a limited history.
		- Adds the newly generated river name to the end of the deque using `push_back` to track its usage.
	 * 4. **Returning Unique River Name:**
	 *    - Returns the generated river name, ensuring it hasn't been used recently within the tracked history.
	 *
	 * @return std::string A unique randomly generated river name
	 *
	 * Time Complexity: O(n) - Linear time.
	 */

	std::string getRandomRiver();

	/**
	 * @brief Checks if two rivers are located on the same continent.
	 *
	 * This function determines whether two rivers belong to the same continent using the internal data structures:
	 * 1. **Continent Lookups:**
	 *    - Calls the `getContinent` function for each river name (`r1` and `r2`) to retrieve their corresponding continents.
	 *    - The `getContinent` function allows the user to search the `rivers` map to find the continent associated with each river name.
	 * 2. **Continent Comparison:**
	 *    - Checks if either continent lookup resulted in an empty string (""). This indicates an error or data inconsistency, and the function returns `false`.
	 *    - If both continent lookups were successful, it compares the retrieved continent names using the inequality operator (`!=`).
		  - If the continent names are different, the rivers are on different continents, and the function returns `false`.
	 * 3. **Same Continent Confirmation:**
	 *    - If both continent lookups were successful and the names match, the rivers are on the same continent, and the function returns `true`.
	 *
	 * @param r1 The name of the first river
	 * @param r2 The name of the second river
	 * @return bool True if the rivers are on the same continent, false otherwise
	 *
	 * Time Complexity: O(1) - Constant time.
	 */

	bool sameContinent(std::string river1, std::string river2);


	/**
	 * @brief Retrieves the continent associated with a given river name.
	 *
	 * This function efficiently retrieves the continent for a river name using the internal `rivers` map:
	 * 1. **Map Lookup:**
	 *    - Uses the provided `river` name as a key to look up its corresponding value in the `rivers` map.
	 *    - The `rivers` map is assumed to store river names as keys and their corresponding continent names as values.
	 * 2. **Continent Return:**
	 *    - If the lookup is successful (the river name exists in the map), the function returns the associated continent name.
	 *    - If the lookup fails (the river name is not found in the map), we set the river to "" which will return false upon comparing the continents.
	 *
	 * @param river The name of the river
	 * @return std::string The continent name associated with the river (or an empty string if not found)
	 *
	 * Time Complexity: O(1) - Constant time.
	 */

	std::string getContinent(std::string river);

	/**
		* @brief Sets the operating mode for random river generation.
		*
		* This function allows the user to select the mode that determines how continents and rivers are weighted during random river generation.
		*
		* @param mode An integer representing the desired mode:
		*   - 1: Equal weights for continents (each continent has an equal chance of being selected).
		*   - 2: Equal weights for individual rivers (each river has an equal chance of being selected, regardless of continent).
		*   - 3: Favor previously used continent (the continent used in the previous generation has a 50% probability of being generated, and the remaining weight is distributed equally among other continents).
		*
		* Time Complexity: O(1) - Constant time.
		*/

	void setMode(int mode) {
		myMode = mode;
	}

	/**
	 * @brief Get the current mode.
	 *
	 * This function returns the value of the `myMode` variable, which represents the current mode.
	 *
	 * @return The current mode value.
	 *
     * Time Complexity: O(1) - Constant time.
	 */

	int getMode() {
		return myMode;
	}
};